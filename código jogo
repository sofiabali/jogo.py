import pygame # type: ignore

pygame.init()

tamanho_da_tela = (1000, 1000)
tela = pygame.display.set_mode(tamanho_da_tela)
pygame.display.set_caption("break e charadas")

tamanho_bola = 15
bola = pygame.Rect(100, 500, tamanho_bola, tamanho_bola)
tamanho_jogador = 100
jogador = pygame.Rect(0, 950, tamanho_jogador, 15)


qntd_blocos_linha = 8
qntd_linha_blocos = 8
qntd_total_blocos = qntd_blocos_linha * qntd_linha_blocos

def criar_blocos(qntd_blocos_linha, qntd_linha_blocos):
    altura_tela = tamanho_da_tela[1]
    largura_tela = tamanho_da_tela[0]
    distancia_bloco = 10
    largura_bloco = largura_tela / 8  - distancia_bloco
    altura_bloco = 20
    distancia_entre_linhas = altura_bloco + 15

def criar_blocos(qntd_blocos_linha, qntd_linha_blocos):
    altura_tela = tamanho_da_tela[1]
    largura_tela = tamanho_da_tela[0]
    distancia_bloco = 10
    largura_bloco = largura_tela / 8 - distancia_bloco
    altura_bloco = 20
    distancia_entre_linhas = altura_bloco + 15

    blocos = []
    cores_dos_blocos = [cores["verde"], cores["amarela"], cores["azul"], cores["rosa"]]  # Lista de cores

    for j in range(qntd_linha_blocos):
        for i in range(qntd_blocos_linha):
            cor = cores_dos_blocos[(i + j) % len(cores_dos_blocos)]  # Alternando cores
            bloco = pygame.Rect(i * (largura_bloco + distancia_bloco), j * distancia_entre_linhas, largura_bloco, altura_bloco)
            blocos.append((bloco, cor))  # Adicionando a cor baseada no índice

    return blocos

def desenhar_blocos(blocos):
    for bloco, cor in blocos:  # Desestruturando a tupla
        pygame.draw.rect(tela, cor, bloco)  # Usando a cor correspondente


cores = {
    "branca":(255, 255, 255),
    "preta":(0, 0, 0),
    "amarela":(255, 255, 0),
    "azul": (0, 0, 255),
    "verde": (0, 255, 0),
    "rosa": (255, 0, 132),
    "vermelho": (255, 0, 0),
    "verdee": (50,205,50),
    "verdeee": (66,111,66),
    "verdeeee": (35,142,104),
    "verdeeeee": (79,79,47)
}


fim_de_jogo = False
pontuacao = 0
movimento_bola = [2 , -2]


def desenhar_inicio_jogo():
    tela.fill(cores["preta"])
    pygame.draw.rect(tela, cores["azul"], jogador)
    pygame.draw.rect(tela, cores["branca"], bola)


def movimentar_jogador(evento):
    if evento.type == pygame.KEYDOWN:
        if evento.key == pygame.K_RIGHT:
            if (jogador.x + tamanho_jogador) < tamanho_da_tela[0]:
                jogador.x = jogador.x + 3
        if evento.key == pygame.K_LEFT:
            if jogador.x > 0:
                jogador.x = jogador.x - 3


def movimentar_bola(bola):
    global movimento_bola  
    bola.x += movimento_bola[0]
    bola.y += movimento_bola[1]

    if bola.x <= 0 or bola.x + tamanho_bola >= tamanho_da_tela[0]:
        movimento_bola[0] = -movimento_bola[0]
    if bola.y <= 0:
        movimento_bola[1] = -movimento_bola[1]
    if bola.y + tamanho_bola >= tamanho_da_tela[1]:
        return False  

    if jogador.collidepoint(bola.x + tamanho_bola // 2, bola.y + tamanho_bola):  
        movimento_bola[1] = -movimento_bola[1]

    for bloco, cor in blocos:
        if bloco.collidepoint(bola.x, bola.y):  
            blocos.remove((bloco, cor))  
            movimento_bola[1] = -movimento_bola[1]
            break  

    return True 
 


def atualizar_pontuacao(pontuacao):
    fonte = pygame.font.Font(None, 30)
    texto = fonte.render(f"pontução: {pontuacao}", 1, cores["amarela"])
    tela.blit(texto, (0, 780))
    if pontuacao >= qntd_total_blocos:
        return True
    else:
        return False
    

    

blocos = criar_blocos(qntd_blocos_linha, qntd_linha_blocos)


def fazer_pergunta():
    pergunta = "Qual é a capital da França?"
    resposta_correta = "Paris"
    
    fonte = pygame.font.Font(None, 36)
    tela.fill(cores["preta"])
    texto = fonte.render(pergunta, True, cores["branca"])
    tela.blit(texto, (50, 400))
    pygame.display.flip()
    
    resposta = ""
    esperando_resposta = True
    
    while esperando_resposta:
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                pygame.quit()
                return False
            
            if evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_RETURN:  
                    if resposta.lower() == resposta_correta.lower():
                        return True  
                    else:
                        return False  
                elif evento.unicode and len(resposta) < 20:  
                    resposta += evento.unicode
                elif evento.key == pygame.K_BACKSPACE: 
                    resposta = resposta[:-1]

        # Atualiza a tela com a resposta atual
        tela.fill(cores["preta"])
        tela.blit(texto, (50, 400))
        resposta_texto = fonte.render(resposta, True, cores["amarela"])
        tela.blit(resposta_texto, (50, 450))
        pygame.display.flip()


while not fim_de_jogo:
    desenhar_inicio_jogo()
    desenhar_blocos(blocos)
    fim_de_jogo = atualizar_pontuacao(qntd_total_blocos - len(blocos))
    
    for evento in pygame.event.get():
        if evento.type == pygame.QUIT:
            fim_de_jogo = True

    movimentar_jogador(evento)
    bola_em_jogo = movimentar_bola(bola)  # Verifica se a bola ainda está em jogo
    if not bola_em_jogo:  # Se a bola caiu
        if fazer_pergunta():  # Se a resposta estiver correta
            # Reiniciar o jogo
            bola.x, bola.y = 100, 500
            blocos = criar_blocos(qntd_blocos_linha, qntd_linha_blocos)  # Recria os blocos
            fim_de_jogo = False  # Reinicia a flag de fim de jogo
        else:
            fim_de_jogo = True  # Encerrar o jogo se a resposta estiver errada

    pygame.time.wait(1)
    pygame.display.flip()

    pygame.quit
